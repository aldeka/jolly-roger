# This YAML file, when loaded and dumped as JSON, can be used as a
# CloudFormation Stack to spin up the jolly-roger environment. YAML is
# used instead of JSON for comments and easier-to-read formatting, but
# we should refrain from using any fancier features of YAML.
#
# The jolly-roger environment consists of:
#
# - A VPC with a public subnet (no support currently for private
#   subnets or NAT)
#
# - A system for fetching secrets using credstash which encrypts
#   secrets using KMS and stores them in DynamoDB.
#
# - An auto-scaling group (ASG) with instances that automatically
#   launch the jolly-roger application.
#
# - The application instances run several docker services:
#
#   - A registry to proxy access to private images
#
#   - An nginx instance for port 80, redirecting to HTTPS and
#     supporting the LetsEncrypt ACME verification process (via an S3
#     bucket)
#
#   - An nginx instance for port 444, listening for HTTPS+PROXY and
#     forwarding to the application
#
#   - The actual Meteor application
#
#   - Watchtower, which periodically pulls image updates
#
# - An Elastic Load Balancer (ELB) in front of the ASG, forwarding
#   ports 80 and 443. It forwards port 443 using the proxy protcol
#   (http://www.haproxy.org/download/1.5/doc/proxy-protocol.txt), such
#   that the instances terminate TLS. This is needed for websocket
#   support (ELB's HTTP implementation does not support websockets)
#
# It's possible this could be used to run multiple parallel copies of
# the jolly-roger website, though that's not very likely in practice.
#
# To spin up an independent copy of jolly-roger, you'll _definitely_
# need to do the following (and probably more I've forgotten):
#
# - Setup credstash (following the directions in the repo)
#
# - Generate the config.yml file for the registry. Starting with
#   http://git.io/vERX3, add a section labeled proxy. Include the keys
#   username and password with values for an account that has access
#   to the ebroder/jolly-roger image, and set remoteurl:
#   https://registry-1.docker.io. Store this using `credstash put
#   registry/config.yml @path`
#
# - Store the MongoDB URL using `credstash put mongo @<path>`. The
#   free account from mongolab (for instance) should be sufficient.

AWSTemplateFormatVersion: "2010-09-09"
Description: jolly-roger

Parameters:
  CredstashKeyUuid:
    Description: UUID of the credstash KMS key
    Type: String
  AppUrl:
    Description: The URL of application
    Type: String
    Default: future.deathandmayhem.com
  AppDomain:
    Description: The zone under which to create DNS records
    Type: AWS::Route53::HostedZone::Id
  KeyName:
    Description: Name of an existing EC2 keypair to allow access to all instances
    Type: AWS::EC2::KeyPair::KeyName
  AppInstanceType:
    Description: Instance type to run for app server
    Type: String
    Default: t2.micro
  PapertrailHost:
    Description: Log host for Papertrail
    Type: String
    Default: ''
    NoEcho: true
  DatadogApiKey:
    Description: API key for DataDog
    Type: String
    Default: ''
    NoEcho: true

Mappings:
  UbuntuAmis:
    us-east-1: {"ami": ami-5c207736}

Conditions:
  HavePapertrail:
    Fn::Not:
      - Fn::Equals:
          - {Ref: PapertrailHost}
          - ''
  HaveDatadog:
    Fn::Not:
      - Fn::Equals:
          - {Ref: DatadogApiKey}
          - ''

Resources:
  VPC:
    Type: AWS::EC2::VPC
    Properties:
      CidrBlock: 10.32.0.0/16
      EnableDnsHostnames: true

  PublicSubnetRouteTable:
    Type: AWS::EC2::RouteTable
    Properties:
      VpcId: {Ref: VPC}

  InternetGateway:
    Type: AWS::EC2::InternetGateway
  InternetGatewayAttachment:
    Type: AWS::EC2::VPCGatewayAttachment
    Properties:
      VpcId: {Ref: VPC}
      InternetGatewayId: {Ref: InternetGateway}
  PublicRouteToInternet:
    Type: AWS::EC2::Route
    Properties:
      DestinationCidrBlock: 0.0.0.0/0
      GatewayId: {Ref: InternetGateway}
      RouteTableId: {Ref: PublicSubnetRouteTable}

  PublicSubnet1:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: {"Fn::Select": [0, {"Fn::GetAZs": ""}]}
      CidrBlock: 10.32.0.0/24
      MapPublicIpOnLaunch: true
      VpcId: {Ref: VPC}
  PublicSubnet1RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: {Ref: PublicSubnetRouteTable}
      SubnetId: {Ref: PublicSubnet1}

  PublicSubnet2:
    Type: AWS::EC2::Subnet
    Properties:
      AvailabilityZone: {"Fn::Select": [1, {"Fn::GetAZs": ""}]}
      CidrBlock: 10.32.1.0/24
      MapPublicIpOnLaunch: true
      VpcId: {Ref: VPC}
  PublicSubnet2RouteTableAssoc:
    Type: AWS::EC2::SubnetRouteTableAssociation
    Properties:
      RouteTableId: {Ref: PublicSubnetRouteTable}
      SubnetId: {Ref: PublicSubnet2}

  # Bucket for serving /.well-known/acme-challenge/
  LetsEncryptBucket:
    Type: AWS::S3::Bucket
    Properties:
      AccessControl: PublicRead

  AppInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: [ec2.amazonaws.com]
            Action: ["sts:AssumeRole"]
      Policies:
        - PolicyName: credstash-download
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - Fn::Join:
                      - ""
                      -
                        - "arn:aws:dynamodb:"
                        - {Ref: "AWS::Region"}
                        - ":"
                        - {Ref: "AWS::AccountId"}
                        - ":table/credential-store"
              - Effect: Allow
                Action:
                  - kms:Decrypt
                Resource:
                  - Fn::Join:
                      - ""
                      -
                        - "arn:aws:kms:"
                        - {Ref: "AWS::Region"}
                        - ":"
                        - {Ref: "AWS::AccountId"}
                        - ":key/"
                        - {Ref: CredstashKeyUuid}

  AppInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Path: /
      Roles:
        - {Ref: AppInstanceRole}

  AppElbSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for app load balancer
      SecurityGroupEgress: []
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 443
          ToPort: 443
      VpcId: {Ref: VPC}
  AppSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for app server instances
      SecurityGroupEgress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: -1
          FromPort: -1
          ToPort: -1
      SecurityGroupIngress:
        - CidrIp: 0.0.0.0/0
          IpProtocol: tcp
          FromPort: 22
          ToPort: 22
        - SourceSecurityGroupId: {Ref: AppElbSecurityGroup}
          IpProtocol: tcp
          FromPort: 80
          ToPort: 80
        # Proxy protocol comes on port 444
        - SourceSecurityGroupId: {Ref: AppElbSecurityGroup}
          IpProtocol: tcp
          FromPort: 444
          ToPort: 444
        # echo request
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 8
          ToPort: -1
        # echo reply
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 0
          ToPort: -1
        # frag needed
        - CidrIp: 0.0.0.0/0
          IpProtocol: icmp
          FromPort: 3
          ToPort: 4
      VpcId: {Ref: VPC}

  AppElb:
    Type: AWS::ElasticLoadBalancing::LoadBalancer
    Properties:
      Subnets:
        - {Ref: PublicSubnet1}
        - {Ref: PublicSubnet2}
      ConnectionDrainingPolicy:
        Enabled: true
        Timeout: 60
      CrossZone: true
      Policies:
        - PolicyName: EnableProxyProtocol
          PolicyType: ProxyProtocolPolicyType
          Attributes:
            - Name: ProxyProtocol
              Value: true
          InstancePorts: [444]
      Listeners:
        - Protocol: HTTP
          LoadBalancerPort: 80
          InstanceProtocol: HTTP
          InstancePort: 80
        - Protocol: TCP
          LoadBalancerPort: 443
          InstanceProtocol: TCP
          InstancePort: 444
      HealthCheck:
        Target: HTTP:80/healthcheck
        Interval: 5
        Timeout: 4
        HealthyThreshold: 2
        UnhealthyThreshold: 2
      SecurityGroups:
        - {Ref: AppElbSecurityGroup}

  AppLaunchConfig:
    Type: AWS::AutoScaling::LaunchConfiguration
    Properties:
      IamInstanceProfile: {Ref: AppInstanceProfile}
      ImageId: 
        Fn::FindInMap:
          - UbuntuAmis
          - {Ref: "AWS::Region"}
          - ami
      BlockDeviceMappings:
        - DeviceName: /dev/sdb
          VirtualName: ephemeral0
        - DeviceName: /dev/sdc
          VirtualName: ephemeral1
        - DeviceName: /dev/sdf
          Ebs:
            VolumeType: gp2
            VolumeSize: 2
            DeleteOnTermination: true
      InstanceType: {Ref: AppInstanceType}
      KeyName: {Ref: KeyName}
      SecurityGroups:
        - {Ref: AppSecurityGroup}
      # We're generating a YAML file inside a YAML file. Yes, this is
      # gross, but it seems to be the best anyone has come up with
      # (especially since we need variable interpolation)
      UserData:
        Fn::Base64:
          Fn::Join:
            - "\n"
            -
              - '#cloud-config'
              - ''
              - 'package_upgrade: true'
              - ''
              - 'apt_sources:'
              # For docker
              - '  - source: "deb https://apt.dockerproject.org/repo ubuntu-$RELEASE main"'
              - '    filename: docker.list'
              - '    keyid: 58118E89F3A912897C070ADBF76221572C52609D'
              - ''
              - 'mounts:'
              - '  - [/dev/xvdf, none, swap, sw, 0, 0]'
              - ''
              - 'packages:'
              - '  - docker-engine'
              - '  - htop'
              - '  - python-dev'
              - '  - python-pip'
              - ''
              - Fn::If:
                  - HavePapertrail
                  - Fn::Join:
                      - ''
                      -
                        - "rsyslog:\n  - configs: [\". @"
                        - {Ref: PapertrailHost}
                        - "\"]"
                  - ''
              - ''
              - 'write_files:'
              - Fn::Join:
                  - ''
                  -
                    - '  - path: /etc/nginx-https/vhost.d/'
                    - {Ref: AppUrl}
              - '    content: |'
              - '      listen 444 ssl http2 proxy_protocol default_server;'
              - '  - path: /etc/nginx-http/conf.d/default.conf'
              - '    content: |'
              - '      server {'
              - '        listen 80;'
              - '        access_log /var/log/nginx/access.log main;'
              - '        location /.well-known/acme-challenge {'
              - Fn::Join:
                  - ''
                  -
                    - '          return 301 https://'
                    - {Ref: LetsEncryptBucket}
                    - '.s3.amazonaws.com$request_uri;'
              - '        }'
              - '        location /healthcheck {'
              - '          return 200 "OK\n";'
              - '        }'
              - '        location / {'
              - '          return 301 https://$host$request_uri;'
              - '        }'
              - '      }'
              - ''
              - 'runcmd:'
              - '  - set -eux'

              - '  - mkswap /dev/xvdf'
              - '  - swapon -a'

              - '  - pip install credstash'
              - Fn::Join:
                  - ''
                  -
                    - '  - export AWS_DEFAULT_REGION='
                    - {Ref: "AWS::Region"}

              # Observability
              - Fn::If:
                  - HavePapertrail
                  - Fn::Join:
                      - ''
                      -
                        - '  - docker run --name logspout -d --restart=unless-stopped -v /var/run/docker.sock:/tmp/docker.sock gliderlabs/logspout:master syslog://'
                        - {Ref: PapertrailHost}
                  - {Ref: "AWS::NoValue"}
              - Fn::If:
                  - HaveDatadog
                  - Fn::Join:
                      - ''
                      -
                        - '  - docker run --name dd-agent -d --restart=unless-stopped -h `hostname` -v /var/run/docker.sock:/var/run/docker.sock -v /proc/:/host/proc/:ro -v /sys/fs/cgroup/:/host/sys/fs/cgroup:ro -e API_KEY='
                        - {Ref: DatadogApiKey}
                        - ' datadog/docker-dd-agent:latest'
                  - {Ref: "AWS::NoValue"}

              # Run a local registry proxy so we don't have to teach everything to auth for our private images
              - '  - mkdir -p /etc/docker/registry'
              - '  - credstash get registry/config.yml > /etc/docker/registry/config.yml'
              - '  - docker run --name registry -d --restart=unless-stopped -p 5000:5000 -v /etc/docker/registry:/etc/docker/registry registry:2'
              - '  - sleep 5'

              # Pre-fetch images
              - '  - docker pull localhost:5000/ebroder/jolly-roger'
              - '  - docker pull jwilder/nginx-proxy'
              - '  - docker pull centurylink/watchtower'

              - '  - docker run --name nginx-http -d --restart=unless-stopped -p 80:80 -v /etc/nginx-http/conf.d:/etc/nginx/conf.d nginx'
              # Give ELB time to pick up the instance
              - '  - sleep 15'

              - Fn::Join:
                  - ''
                  -
                    - '  - docker run --name jolly-roger -d --restart=unless-stopped -e AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION'
                    - ' -e VIRTUAL_HOST='
                    - {Ref: AppUrl}
                    - ' -e ROOT_URL=https://'
                    - {Ref: AppUrl}
                    - ' localhost:5000/ebroder/jolly-roger'

              - '  - mkdir /etc/nginx-https/certs'
              - Fn::Join:
                  - ''
                  -
                    - '  - credstash get ssl/cert.pem > /etc/nginx-https/certs/'
                    - {Ref: AppUrl}
                    - '.crt'
              - Fn::Join:
                  - ''
                  -
                    - '  - credstash get ssl/privkey.pem > /etc/nginx-https/certs/'
                    - {Ref: AppUrl}
                    - '.key'

              - '  - docker run --name nginx-https -d --restart=unless-stopped -p 444:444 -v /var/run/docker.sock:/tmp/docker.sock:ro -v /etc/nginx-https/vhost.d:/etc/nginx/vhost.d -v /etc/nginx-https/certs:/etc/nginx/certs jwilder/nginx-proxy'
              - '  - docker run --name watchtower -d --restart=unless-stopped -v /var/run/docker.sock:/var/run/docker.sock centurylink/watchtower --interval 30 --cleanup'
    DependsOn:
      - InternetGatewayAttachment

  AppAsg:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      HealthCheckType: ELB
      HealthCheckGracePeriod: 900
      LaunchConfigurationName: {Ref: AppLaunchConfig}
      VPCZoneIdentifier:
        - {Ref: PublicSubnet1}
        - {Ref: PublicSubnet2}
      MaxSize: 1
      MinSize: 1
      LoadBalancerNames:
        - {Ref: AppElb}
    UpdatePolicy:
      AutoScalingRollingUpdate:
        WaitOnResourceSignals: false
        MinSuccessfulInstancesPercent: 100
        MinInstancesInService: 0

  AppDns:
    Type: AWS::Route53::RecordSet
    Properties:
      HostedZoneId: {Ref: AppDomain}
      Name: {Ref: AppUrl}
      Type: A
      AliasTarget:
        HostedZoneId: {"Fn::GetAtt": [AppElb, CanonicalHostedZoneNameID]}
        DNSName: {"Fn::GetAtt": [AppElb, CanonicalHostedZoneName]}
